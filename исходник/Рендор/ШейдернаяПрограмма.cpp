#include "Ўейдерна€ѕрограмма.h"

#include<glm/gtc/type_ptr.hpp>

#include <iostream>

namespace ƒвижок–ендеринга {
	Ўейдерна€ѕрограмма::Ўейдерна€ѕрограмма(const std::string& ¬ершинныйЎейдер, const std::string& ‘рагментныйЎейдер)
	{
		
		GLint ¬ершинныйЎейдерјдрес = 0 ;
		if (!сотворитьЎейдер(¬ершинныйЎейдер, GL_VERTEX_SHADER, ¬ершинныйЎейдерјдрес))
		{
			std::cerr << "¬ершинный Ўейдер ошибка во врем€ компел€ци€" << std::endl;
			return;
		}

		GLint ‘рагментныйЎейдерјдрес = 0;
		if (!сотворитьЎейдер(‘рагментныйЎейдер, GL_FRAGMENT_SHADER, ‘рагментныйЎейдерјдрес))
		{
			std::cerr << "‘рагментный Ўейдер ошибка во врем€ компел€ци€" << std::endl;
			glDeleteShader(¬ершинныйЎейдерјдрес);
			return;
		}

		идиф_шедор = glCreateProgram();
		glAttachShader(идиф_шедор, ¬ершинныйЎейдерјдрес);
		glAttachShader(идиф_шедор, ‘рагментныйЎейдерјдрес);
		glLinkProgram(идиф_шедор);

		GLint успех  ;
		glGetProgramiv(идиф_шедор, GL_LINK_STATUS, &успех);
		if (!успех)
		{
			GLchar инфологе[1024];
			glGetShaderInfoLog(идиф_шедор, 1024, nullptr, инфологе);
			std::cerr << "ќЎ»Ѕ ј::Ў≈ƒќ–ј:ќшибко во врем€ линкофка\n"<< инфологе << std::endl;
			
		}
		else
		{
			проверка_ омпел€цииЎедор = true;
		}
		
		glDeleteShader(¬ершинныйЎейдерјдрес);
		glDeleteShader(‘рагментныйЎейдерјдрес);
	}

	bool Ўейдерна€ѕрограмма::сотворитьЎейдер(const std::string& источник, const GLenum “ипЎейдера, GLint &шейдерајдрес)
	{
		шейдерајдрес = glCreateShader(“ипЎейдера);
		const char* код = источник.c_str();
		glShaderSource(шейдерајдрес, 1, &код, nullptr);
		glCompileShader(шейдерајдрес);


		GLint успех;
		glGetShaderiv(шейдерајдрес, GL_COMPILE_STATUS, &успех);
		if (!успех)
		{
			GLchar инфологе[1024];
			glGetShaderInfoLog(шейдерајдрес, 1024, nullptr, инфологе);
			std::cerr << "ќЎ»Ѕ ј::Ў≈ƒќ–ј:ќшибко во врем€ компил€ци€\n"<< инфологе<<std::endl;
			return false;
		}
		return true;
	}

	Ўейдерна€ѕрограмма::~Ўейдерна€ѕрограмма()
	{
		glDeleteProgram(идиф_шедор);
	}

	void Ўейдерна€ѕрограмма::вкл() const
	{
		glUseProgram(идиф_шедор);
	}
	Ўейдерна€ѕрограмма& Ўейдерна€ѕрограмма::operator=( Ўейдерна€ѕрограмма&& Ўейдерна€ѕрограмма) noexcept
	{
		glDeleteProgram(идиф_шедор);
		идиф_шедор = Ўейдерна€ѕрограмма.идиф_шедор;
		проверка_ омпел€цииЎедор = Ўейдерна€ѕрограмма.проверка_ омпел€цииЎедор;


		Ўейдерна€ѕрограмма.идиф_шедор = 0;
		Ўейдерна€ѕрограмма.проверка_ омпел€цииЎедор = false;
		return* this; 
	}

	 Ўейдерна€ѕрограмма::Ўейдерна€ѕрограмма (Ўейдерна€ѕрограмма&& Ўейдерна€ѕрограмма) noexcept
	{
		 идиф_шедор = Ўейдерна€ѕрограмма.идиф_шедор;
		 проверка_ омпел€цииЎедор = Ўейдерна€ѕрограмма.проверка_ омпел€цииЎедор;


		 Ўейдерна€ѕрограмма.идиф_шедор = 0;
		 Ўейдерна€ѕрограмма.проверка_ омпел€цииЎедор = false;
	}

	 void Ўейдерна€ѕрограмма::сохраниеть«начение(const std::string& им€, GLint значение)
	 {
		 glUniform1i(glGetUniformLocation(идиф_шедор, им€.c_str()), значение);

	 }


	 void Ўейдерна€ѕрограмма::сохранитьћатрицу4(const std::string& им€, glm::mat4& матрица)
	 {
		 glUniformMatrix4fv(glGetUniformLocation(идиф_шедор, им€.c_str()),1, GL_FALSE, glm::value_ptr(матрица));

	 }
}
